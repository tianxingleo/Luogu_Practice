#include <stdio.h>

int main() {
    // 1. 定义和初始化二维数组 c[4][5]
    int c[4][5] = {
        {10, 11, 12, 13, 14}, // c[0]
        {20, 21, 22, 23, 24}, // c[1]
        {30, 31, 32, 33, 34}, // c[2]
        {40, 41, 42, 43, 44}  // c[3]
    };

    // 2. 声明并赋值数组指针 p
    // p 是一个指针，指向一个包含 5 个 int 元素的数组（即 c 的一行）
    int (*p)[5]; 
    p = c; 
    
    // --- 验证选项 B ---
    printf("=== 验证选项 B: *(p+3) ===\n");
    
    // 理论分析: 
    // p+3  -> 指向 c[3] (第 4 行) 的地址 &c[3]
    // *(p+3) -> c[3] 这个一维数组。
    // 在表达式中，c[3] 退化为指向其首元素 c[3][0] 的指针。
    
    // 打印指针的地址（值）
    printf("表达式 p 的值是 (地址): %p\n", p); 
    printf("表达式 *p 的值是 (地址): %p\n", *p); 
    printf("表达式 **p 的值是 (地址): %p\n", **p); 
    printf("表达式 *(p+3) 的值是 (地址): %p\n", *(p+3)); 
    printf("它指向的理论地址是 &c[3][0]: %p\n", &c[3][0]); 
    
    // 验证 *(p+3) 指向的第一个元素的值
    // 对退化后的指针 *(p+3) 再次解引用，得到 c[3][0] 的值
    printf("对 *(p+3) 解引用 (*(*(p+3))) 得到的值 c[3][0] 是: %d\n", *(*(p+3))); 
    
    // 结论: *(p+3) 是 c[3] 这一行数组名退化后的指针，它不能直接引用一个元素的值，但可以用来引用元素地址。
    
    printf("\n");

    // --- 验证选项 D ---
    printf("=== 验证选项 D: *(p[0]+2) ===\n");
    
    // 理论分析:
    // p[0] 等价于 *(p+0)，即 c[0] 这个一维数组。
    // p[0] 退化为指向 c[0][0] 的指针 (&c[0][0])。
    // p[0]+2 -> 指针 c[0] 向后移动 2 个 int 元素，指向 &c[0][2]。
    // *(p[0]+2) -> 对地址 &c[0][2] 解引用，得到 c[0][2] 的值。

    // 打印表达式的值
    int value_D = *(p[0]+2);
    printf("表达式 *(p[0]+2) 得到的值是: %d\n", value_D); 
    
    // 验证它是否是 c[0][2]
    printf("c[0][2] 的理论值是: %d\n", c[0][2]); // 理论值是 12
    
    // 结论: *(p[0]+2) 成功解引用了数组元素 c[0][2] 的值，因此是正确引用数组元素值的表达式。

    return 0;
}